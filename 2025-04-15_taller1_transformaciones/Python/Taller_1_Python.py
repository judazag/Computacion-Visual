# -*- coding: utf-8 -*-
"""Computacion_Visual.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kLiUa_8RtNMTatFobjmU0nQhPpzgg2T2
"""

import numpy as np
import matplotlib.pyplot as plt
import imageio

# Crear figura base (un cuadrado)
figura = np.array([
    [0, 0],
    [1, 0],
    [1, 1],
    [0, 1],
    [0, 0]  # para cerrar la figura
]).T  # 2xN para facilitar transformaciones

# Funciones de matrices
def matriz_traslacion(dx, dy):
    return np.array([
        [1, 0, dx],
        [0, 1, dy],
        [0, 0, 1]
    ])

def matriz_rotacion(theta):
    return np.array([
        [np.cos(theta), -np.sin(theta), 0],
        [np.sin(theta), np.cos(theta), 0],
        [0, 0, 1]
    ])

def matriz_escala(sx, sy):
    return np.array([
        [sx, 0, 0],
        [0, sy, 0],
        [0, 0, 1]
    ])

def hacer_homogenea(fig):
    ones = np.ones((1, fig.shape[1]))
    return np.vstack([fig, ones])

# Inicializar
frames = []
num_frames = 60

for t in range(num_frames):
    angulo = 2 * np.pi * t / num_frames  # Rota 360 grados
    escala = 1 + 0.5 * np.sin(2 * np.pi * t / num_frames)  # Oscila la escala
    dx = 2 * np.cos(2 * np.pi * t / num_frames)  # Movimiento horizontal
    dy = 2 * np.sin(2 * np.pi * t / num_frames)  # Movimiento vertical

    # Crear matrices
    T = matriz_traslacion(dx, dy)
    R = matriz_rotacion(angulo)
    S = matriz_escala(escala, escala)

    # Aplicar transformación total
    transformacion_total = T @ R @ S
    figura_homogenea = hacer_homogenea(figura)
    figura_transformada = transformacion_total @ figura_homogenea

    # Graficar
    fig, ax = plt.subplots(figsize=(6, 6))
    ax.plot(figura_transformada[0, :], figura_transformada[1, :], 'bo-')
    ax.set_xlim(-5, 5)
    ax.set_ylim(-5, 5)
    ax.set_aspect('equal')
    ax.set_title(f'Frame {t}')

    # Mostrar matriz en la gráfica
    matriz_texto = np.array2string(transformacion_total, precision=2, suppress_small=True)
    ax.text(
        0.05, 0.95,
        f'Matriz:\n{matriz_texto}',
        fontsize=8,
        transform=ax.transAxes,  # <- Esto es importante: usa coordenadas relativas al gráfico
        verticalalignment='top',
        family='monospace',
        bbox=dict(boxstyle="round,pad=0.3", facecolor="white", edgecolor="gray")
    )

    # Guardar el frame
    plt.savefig(f'frame_{t}.png')
    plt.close()

    frames.append(imageio.imread(f'frame_{t}.png'))

# Guardar como GIF
imageio.mimsave('transformacion.gif', frames, duration=0.05)
